# Converting from Interpreted to Compiled

This document explains the steps taken to convert the Vibe Programming Language from an interpreted language to a compiled language targeting ARM64 architecture.

## Overview of Changes

1. **Created three compiler backends:**
   - `compiler.py`: Direct ARM64 assembly generation (main approach)
   - `simple_compiler.py`: Simplified ARM64 code generator focusing on core functionality
   - `llvm_compiler.py`: Uses LLVM IR for optimized compilation

2. **Created a unified compiler interface:**
   - `vibe_compiler.py`: Command-line tool to select compile options and backends

3. **Assembly Code Generation:**
   - Each compiler backend traverses the AST generated by the parser
   - Converts AST nodes into corresponding ARM64 assembly or LLVM IR
   - Handles memory management, register allocation, and system calls

4. **Runtime Support:**
   - Implemented basic string operations (concatenation)
   - Added I/O operations via syscalls
   - Memory management for variables and strings

## Compilation Process

1. **Lexical Analysis** (unchanged from interpreter)
   - Tokenize source code into language tokens

2. **Syntax Analysis** (unchanged from interpreter)
   - Parse tokens into an Abstract Syntax Tree (AST)

3. **Code Generation** (new)
   - Traverse the AST to generate target code
   - Create appropriate data structures and instructions
   - Generate assembly, object files, and final executable

4. **Linking** (new)
   - Link compiled object code with any required libraries
   - Create executable binary file

## Architecture Considerations for ARM64

- **Register Usage:**
  - ARM64 has 31 general-purpose registers (x0-x30)
  - x0-x7 used for function arguments and return values
  - x8 used for syscall numbers
  - x29 (frame pointer) and x30 (link register) managed carefully

- **Memory Model:**
  - Stack-based variable storage
  - Heap allocation for dynamic strings
  - Proper alignment (16-byte) for ARM64 ABI

- **System Calls:**
  - Using ARM64 Linux syscall conventions
  - syscall number in x8, arguments in x0-x5
  - SVC #0 instruction to trigger syscall

## Performance Optimizations

- **String Operations:**
  - Optimized string concatenation
  - In-place operations where possible

- **Register Allocation:**
  - Minimized memory access by keeping values in registers
  - Proper register saving/restoring at function boundaries

- **LLVM Backend:**
  - Access to LLVM's powerful optimization pipeline
  - Target-specific optimizations for ARM64

## Future Improvements

1. **Add more language features:**
   - Numeric operations
   - Control flow (if/else, loops)
   - Functions and proper scope management
   - More data types

2. **Optimize compilation:**
   - Improve register allocation
   - Add more aggressive optimizations
   - Better memory management

3. **Cross-platform support:**
   - Add x86-64 target
   - Support for Windows/MacOS
